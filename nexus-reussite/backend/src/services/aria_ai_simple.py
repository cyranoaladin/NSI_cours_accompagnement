"""
Service IA ARIA - Version simplifi√©e pour d√©ploiement
Cette version fonctionne sans d√©pendances externes lourdes
"""

import json
import random
from datetime import datetime
from typing import Any, Dict, List


class ARIAService:
    def __init__(self):
        self.responses_templates = {
            "greeting": [
                "Bonjour ! Je suis ARIA, votre assistant IA personnel de Nexus R√©ussite. Comment puis-je vous aider aujourd'hui ?",
                "Salut ! Pr√™t(e) √† apprendre ensemble ? Je suis l√† pour vous accompagner dans votre parcours d'excellence.",
                "Bienvenue ! Je suis ARIA, votre coach IA adaptatif. Que souhaitez-vous √©tudier aujourd'hui ?",
            ],
            "math": [
                "Les math√©matiques sont passionnantes ! Avec votre style d'apprentissage, nous allons d√©composer le probl√®me √©tape par √©tape.",
                "Excellente question en math√©matiques ! Je vais adapter mon explication √† votre profil d'apprentissage.",
                "Les maths deviennent plus faciles quand on utilise la bonne m√©thode. Laissez-moi vous guider !",
            ],
            "study_tips": [
                "Pour am√©liorer vos notes, je recommande une approche personnalis√©e bas√©e sur votre style d'apprentissage.",
                "Voici mes conseils adapt√©s √† votre profil : planification, r√©visions actives et pratique r√©guli√®re.",
                "L'excellence vient de la r√©gularit√© et de la m√©thode. Cr√©ons ensemble votre plan d'√©tude personnalis√© !",
            ],
            "bac_prep": [
                "La pr√©paration au bac n√©cessite une strat√©gie bien d√©finie. Je vais vous aider √† cr√©er un plan d'√©tude optimal.",
                "Pour r√©ussir votre bac, nous allons travailler sur vos points forts et renforcer vos faiblesses.",
                "Le bac se pr√©pare m√©thodiquement. Analysons ensemble vos besoins et cr√©ons votre feuille de route !",
            ],
            "subjects": [
                "Analysons vos mati√®res pour identifier celles qui n√©cessitent le plus d'attention.",
                "Chaque mati√®re a ses sp√©cificit√©s. Je vais vous proposer des strat√©gies adapt√©es √† chacune.",
                "Vos mati√®res √† renforcer d√©pendent de vos objectifs. Parlons-en pour personnaliser votre parcours !",
            ],
            "default": [
                "C'est une excellente question ! Adaptons notre approche √† votre style d'apprentissage.",
                "Je vais vous aider avec une m√©thode personnalis√©e selon votre profil cognitif.",
                "Int√©ressant ! Laissez-moi vous proposer une approche adapt√©e √† vos besoins sp√©cifiques.",
            ],
        }

    def detect_message_type(self, message: str) -> str:
        """D√©tecte le type de message pour choisir la r√©ponse appropri√©e"""
        message_lower = message.lower()

        if any(
            word in message_lower for word in ["bonjour", "salut", "hello", "bonsoir"]
        ):
            return "greeting"
        elif any(
            word in message_lower
            for word in ["math√©matiques", "maths", "calcul", "√©quation", "fonction"]
        ):
            return "math"
        elif any(
            word in message_lower
            for word in ["am√©liorer", "notes", "r√©sultats", "conseils"]
        ):
            return "study_tips"
        elif any(
            word in message_lower
            for word in ["bac", "baccalaur√©at", "examen", "pr√©parer"]
        ):
            return "bac_prep"
        elif any(
            word in message_lower
            for word in ["mati√®res", "mati√®re", "renforcer", "faible"]
        ):
            return "subjects"
        else:
            return "default"

    def generate_chat_response(
        self, student_profile: Dict, message: str, context: Dict = None
    ) -> Dict[str, Any]:
        """G√©n√®re une r√©ponse de chat personnalis√©e"""
        try:
            # D√©tection du type de message
            message_type = self.detect_message_type(message)

            # S√©lection d'une r√©ponse appropri√©e
            responses = self.responses_templates.get(
                message_type, self.responses_templates["default"]
            )
            response_text = random.choice(responses)

            # Personnalisation selon le profil
            learning_style = student_profile.get("learning_style", "adaptatif")
            grade_level = student_profile.get("grade_level", "lyc√©e")

            # Ajout de badges contextuels
            badges = [
                {
                    "text": f"üéØ Style: {learning_style.title()}",
                    "class": "bg-blue-100 text-blue-800",
                },
                {
                    "text": f"üìä Confiance: {random.randint(85, 98)}%",
                    "class": "bg-green-100 text-green-800",
                },
            ]

            # Ajout de badges sp√©cifiques selon le type de message
            if message_type == "math":
                badges.append(
                    {
                        "text": "üî¢ Sp√©cialiste Maths",
                        "class": "bg-purple-100 text-purple-800",
                    }
                )
            elif message_type == "bac_prep":
                badges.append(
                    {"text": "üéì Coach Bac", "class": "bg-orange-100 text-orange-800"}
                )

            return {
                "response": response_text,
                "badges": badges,
                "confidence_score": random.uniform(0.85, 0.98),
                "processing_time_ms": random.randint(150, 800),
                "message_type": message_type,
                "personalized": True,
            }

        except Exception as e:
            # R√©ponse de fallback en cas d'erreur
            return {
                "response": "Je rencontre une petite difficult√© technique. Pouvez-vous reformuler votre question ?",
                "badges": [
                    {"text": "‚ö†Ô∏è Mode d√©grad√©", "class": "bg-orange-100 text-orange-800"}
                ],
                "confidence_score": 0.7,
                "processing_time_ms": 100,
                "error": str(e),
            }

    def analyze_learning_style(self, student_data: Dict) -> Dict[str, Any]:
        """Analyse le style d'apprentissage de l'√©tudiant"""
        # Simulation d'analyse bas√©e sur les donn√©es d'interaction
        styles = ["visuel", "auditif", "kinesth√©sique", "lecture/√©criture"]

        # Analyse simul√©e
        dominant_style = random.choice(styles)

        scores = {
            "visuel": random.uniform(0.6, 0.9),
            "auditif": random.uniform(0.5, 0.8),
            "kinesth√©sique": random.uniform(0.4, 0.7),
            "lecture_ecriture": random.uniform(0.5, 0.8),
        }

        return {
            "dominant_style": dominant_style,
            "scores": scores,
            "confidence": random.uniform(0.8, 0.95),
            "recommendations": [
                f"Privil√©gier les m√©thodes {dominant_style}s",
                "Varier les supports d'apprentissage",
                "Adapter le rythme selon les performances",
            ],
        }

    def generate_personalized_content(
        self, student_profile: Dict, subject: str, topic: str
    ) -> Dict[str, Any]:
        """G√©n√®re du contenu personnalis√© pour un sujet donn√©"""
        learning_style = student_profile.get("learning_style", "adaptatif")

        content = {
            "explanation": f"Explication adapt√©e au style {learning_style} pour le sujet {topic} en {subject}.",
            "exercises": [
                {
                    "title": f"Exercice d'application - {topic}",
                    "difficulty": "facile",
                    "type": "application_directe",
                },
                {
                    "title": f"Exercice de synth√®se - {topic}",
                    "difficulty": "moyen",
                    "type": "synthese",
                },
                {
                    "title": f"Exercice d'approfondissement - {topic}",
                    "difficulty": "difficile",
                    "type": "approfondissement",
                },
            ],
            "methodology_tips": [
                f"Adapter la m√©thode au style {learning_style}",
                "Pratiquer r√©guli√®rement avec des exercices vari√©s",
                "Faire des liens avec les connaissances ant√©rieures",
            ],
            "resources": [
                f"Ressources {learning_style}s recommand√©es",
                "Supports compl√©mentaires adapt√©s",
                "Outils d'auto-√©valuation",
            ],
        }

        return content

    def assess_student_performance(
        self, student_id: int, session_data: Dict
    ) -> Dict[str, Any]:
        """√âvalue les performances de l'√©tudiant"""
        answers = session_data.get("answers", [])
        questions = session_data.get("questions", [])

        if not questions:
            return {"error": "Aucune question fournie pour l'√©valuation"}

        # Simulation d'√©valuation
        score = random.uniform(60, 95)

        detailed_analysis = []
        for i, question in enumerate(questions):
            is_correct = random.choice([True, False, True])  # Biais vers le succ√®s
            detailed_analysis.append(
                {
                    "question_id": i + 1,
                    "is_correct": is_correct,
                    "topic": question.get("topic", "general"),
                    "difficulty": question.get("difficulty", "medium"),
                }
            )

        # Analyse des patterns d'erreur
        error_patterns = {
            "calculation_errors": random.randint(0, 2),
            "methodology_issues": random.randint(0, 1),
            "comprehension_gaps": random.randint(0, 1),
        }

        # Recommandations
        recommendations = [
            "Continuer sur cette lanc√©e, excellent travail !",
            "Renforcer la m√©thodologie sur les points identifi√©s",
            "Pratiquer davantage les exercices de type similaire",
        ]

        return {
            "score": score,
            "detailed_analysis": detailed_analysis,
            "error_patterns": error_patterns,
            "recommendations": recommendations,
            "next_difficulty_level": "intermediate" if score > 75 else "basic",
            "confidence": random.uniform(0.8, 0.95),
        }
